%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{microservices overview}
\date{Aug 27, 2019}
\release{1.0.0}
\author{张建}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


微服务是系统架构的一种设计风格，主旨是将一个原本独立的系统拆分成多个小型系统，这些系统在各自独立的进程中运行，服务间通过HTTP的RESTful API进行通信协作。被拆分成的每个小型服务都围绕系统中某一项或一些耦合性较高都业务功能进行构建，每个服务都维护着自身的数据存储、业务开发、自动化测试案例以及独立部署机制。

与单体系统的区别：
\begin{itemize}
\item {} 
微服务系统易于扩展，对于新的业务可方便接入到现有系统中；

\item {} 
解决单体系统的臃肿庞大难以维护，将系统按业务功能模块拆分成多个微服务，每个微服务专注于解决对应业务领域问题，更易于维护；

\item {} 
每个服务运行在自己的进程内，在部署上有稳固的部署边界，每个服务的部署更新不影响其它服务的运行；

\item {} 
系统按功能模块拆分成多个微服务，数据库也将根据业务进行拆分，使得单个微服务数据库表、数据量得到控制；

\end{itemize}

引入的问题:
\begin{itemize}
\item {} 
跨服务调用，增加时间开销

\item {} 
分布式事务一致性问题引入，给系统带来灾难性影响

\item {} 
幂等性问题引入

\item {} 
分库分表带来性能上的影响

\end{itemize}


\chapter{3.目录}
\label{\detokenize{index:id2}}

\section{微服务}
\label{\detokenize{00.summary/summary:id1}}\label{\detokenize{00.summary/summary::doc}}

\subsection{1.概述}
\label{\detokenize{00.summary/summary_01:id1}}\label{\detokenize{00.summary/summary_01::doc}}
微服务是系统架构的一种设计风格，主旨是将一个原本独立的系统拆分成多个小型系统，这些系统在各自独立的进程中运行，服务间通过HTTP的RESTful API进行通信协作。被拆分成的每个小型服务都围绕系统中某一项或一些耦合性较高的业务功能进行构建，每个服务都维护着自身的数据存储、业务开发、自动化测试案例以及独立部署机制。

与单体系统的区别：
\begin{itemize}
\item {} 
微服务系统易于扩展，对于新的业务可方便接入到现有系统中；

\item {} 
解决单体系统的臃肿庞大难以维护，将系统按业务功能模块拆分成多个微服务，每个微服务专注于解决对应业务领域问题，更易于维护；

\item {} 
每个服务运行在自己的进程内，在部署上有稳固的部署边界，每个服务的部署更新不影响其它服务的运行；

\item {} 
系统按功能模块拆分成多个微服务，数据库也将根据业务进行拆分，使得单个微服务数据库表、数据量得到控制；

\end{itemize}

引入的问题:
\begin{itemize}
\item {} 
跨服务调用，增加时间开销

\item {} 
分布式事务一致性问题引入，给系统带来灾难性影响

\item {} 
幂等性问题引入

\item {} 
分库分表带来性能上的影响

\end{itemize}


\section{Spring Cloud}
\label{\detokenize{01.spring-cloud/spring-cloud:spring-cloud}}\label{\detokenize{01.spring-cloud/spring-cloud::doc}}

\subsection{Spring Cloud}
\label{\detokenize{01.spring-cloud/01.introduction/introduction:spring-cloud}}\label{\detokenize{01.spring-cloud/01.introduction/introduction::doc}}

\subsubsection{简介}
\label{\detokenize{01.spring-cloud/01.introduction/introduction_01:id1}}\label{\detokenize{01.spring-cloud/01.introduction/introduction_01::doc}}
Spring Cloud是一个基于Spring Boot实现的微服务架构开发工具。给出了在实际应用中出现各种问题的解决方案和开源框架。

\noindent\sphinxincludegraphics{{spring_cloud}.png}

基础组件:
\begin{itemize}
\item {} 
Spring Cloud Eureka: 服务治理组件,包含服务注册中心、服务注册与发现机制的实现。

\item {} 
Spring Cloud Hystrix: 容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。

\item {} 
Spring Cloud Ribbon: 客户端负载均衡的服务调用组件。

\item {} 
Spring Cloud Feign: 基于Ribbon和Hystrix的声明式服务调用组件。

\item {} 
Spring Cloud Zuul: 网关组件，提供智能路由、访问过滤等功能。

\item {} 
Spring Cloud Stream: 消息驱动事件模型。

\item {} 
Spring Cloud Security: 安全工具包，提供Zull代理中对OAuth2请求对中继器。

\item {} 
Spring Cloud Config: 配置管理工具，可以实现应用配置的外部化存储，并支持配置信息刷新、加密/解密。

\end{itemize}


\subsection{Spring Cloud Eureka}
\label{\detokenize{01.spring-cloud/02.eureka/eureka:spring-cloud-eureka}}\label{\detokenize{01.spring-cloud/02.eureka/eureka::doc}}

\subsubsection{服务治理}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:id1}}\label{\detokenize{01.spring-cloud/02.eureka/eureka_01::doc}}
服务治理组件是微服务架构最核心和基础的模块，主要实现各个微服务实例的自动注册与发现。


\paragraph{服务注册}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:id2}}
每个微服务向注册中心登记自己提供的服务，将主机、端口、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。注册中心维护一个心跳去监测清单中服务是否可用，若不可用从服务清单中剔除。


\paragraph{服务发现}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:id3}}
在服务治理框架下运行，服务间的调用不用指定具体服务实例的地址，而是通过服务名发起请求调用实现。调用方需要向注册中心咨询服务，获取所有服务列表，实现对具体服务的调用。对于同一个服务名多个服务实例，调用方将以某种策略获取出一个位置进行访问。


\subsubsection{Eureka}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:eureka}}

\paragraph{Eureka服务端}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:id4}}
Eureka服务端即服务注册中心。提供注册中心相关功能，可以集群方式部署


\paragraph{Eureka客户端}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_01:id5}}
处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序代码中，应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新服务租约。同时，也能从服务端查询当前注册的服务信息列表并缓存到本地并周期性地刷新服务状态。


\subsubsection{搭建服务注册中心}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_02:id1}}\label{\detokenize{01.spring-cloud/02.eureka/eureka_02::doc}}
1.创建基础Spring Boot工程，命名为eureka-server，并在pom.xml中引入必要的依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}parent\PYGZgt{}
  \PYGZlt{}groupId\PYGZgt{}org.springframework.boot\PYGZlt{}/groupId\PYGZgt{}
  \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZhy{}parent\PYGZlt{}/artifactId\PYGZgt{}
  \PYGZlt{}version\PYGZgt{}1.5.14.RELEASE\PYGZlt{}/version\PYGZgt{}
  \PYGZlt{}relativePath/\PYGZgt{} \PYGZlt{}!\PYGZhy{}\PYGZhy{} lookup parent from repository \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}/parent\PYGZgt{}
\PYGZlt{}dependencies\PYGZgt{}
  \PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.boot\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZhy{}undertow\PYGZlt{}/artifactId\PYGZgt{}
  \PYGZlt{}/dependency\PYGZgt{}
  \PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.boot\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZhy{}web\PYGZlt{}/artifactId\PYGZgt{}
    \PYGZlt{}exclusions\PYGZgt{}
      \PYGZlt{}exclusion\PYGZgt{}
        \PYGZlt{}groupId\PYGZgt{}org.springframework.boot\PYGZlt{}/groupId\PYGZgt{}
        \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZhy{}tomcat\PYGZlt{}/artifactId\PYGZgt{}
      \PYGZlt{}/exclusion\PYGZgt{}
     \PYGZlt{}/exclusions\PYGZgt{}
   \PYGZlt{}/dependency\PYGZgt{}
   \PYGZlt{}dependency\PYGZgt{}
     \PYGZlt{}groupId\PYGZgt{}org.springframework.cloud\PYGZlt{}/groupId\PYGZgt{}
     \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}eureka\PYGZhy{}server\PYGZlt{}/artifactId\PYGZgt{}
   \PYGZlt{}/dependency\PYGZgt{}
\PYGZlt{}/dependencies\PYGZgt{}
\end{sphinxVerbatim}

2.@EnableEurekaServer注解启动一个服务注册中心:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableEurekaServer}
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{EurekaServerApplication} \PYG{p}{\PYGZob{}}

        \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{EurekaServerApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.添加bootstrap.yum文件:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{server}\PYG{p}{:}
  \PYG{n}{port}\PYG{p}{:} \PYG{l+m+mi}{8000}
\PYG{n}{spring}\PYG{p}{:}
  \PYG{n}{application}\PYG{p}{:}
    \PYG{n}{name}\PYG{p}{:} \PYG{n}{eureka}\PYG{o}{\PYGZhy{}}\PYG{n}{server}
\end{sphinxVerbatim}

4.添加application.yml配置文件:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
eureka:
  instance:
    preferIpAddress: true
    leaseRenewalIntervalInSeconds: 10
    leaseExpirationDurationInSeconds: 30
  client:
    register\PYGZhy{}with\PYGZhy{}eureka: false
    fetch\PYGZhy{}registry: false
    serviceUrl:
      defaultZone: \PYGZdl{}\PYGZob{}EUREKA\PYGZus{}DEFAULT\PYGZus{}ZONE:http://localhost:8000/eureka/\PYGZcb{}
    registryFetchIntervalSeconds: 10
    disable\PYGZhy{}delta: true
  server:
    evictionIntervalTimerInMs: 4000
\end{sphinxVerbatim}

eureka.client.register-with-eureka: 设置是否向注册中心注册服务，因为本身为注册中心不需要注册自己。如果是注册中心集群则不需要此配置，默认为true。

eureka.client.fetch-registry: 设置是否去注册中心检索服务，因为本身为注册中心维护有服务列表不用去检索。如果为注册中心集群则不需此配置，默认为true。

eureka.client.serviceUrl.defaultZone: 注册中心地址

eureka.client.registryFetchIntervalSeconds: 间隔多久去拉取服务注册信息，默认30秒


\subsubsection{服务提供者}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_02:id2}}
1.创建一个Spring Boot项目，命名为oauth-server，pom.xml如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{boot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{undertow}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{boot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{web}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{exclusions}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{exclusion}\PYG{o}{\PYGZgt{}}
            \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{boot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
            \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{tomcat}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{exclusion}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{exclusions}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{boot}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{boot}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{scope}\PYG{o}{\PYGZgt{}}\PYG{n}{test}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{netflix}\PYG{o}{\PYGZhy{}}\PYG{n}{eureka}\PYG{o}{\PYGZhy{}}\PYG{n}{client}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

2.添加@EnableDiscoveryClent注解，开启服务发现功能:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableEurekaClient}
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{OauthServerApplication} \PYG{p}{\PYGZob{}}

        \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{OauthServerApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.添加bootstrap.yml配置文件:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{server}\PYG{p}{:}
  \PYG{n}{port}\PYG{p}{:} \PYG{l+m+mi}{8020}
\PYG{n}{spring}\PYG{p}{:}
  \PYG{n}{application}\PYG{p}{:}
    \PYG{n}{name}\PYG{p}{:} \PYG{n}{oauth}\PYG{o}{\PYGZhy{}}\PYG{n}{server}
\end{sphinxVerbatim}

4.添加applocation.yml文件:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
eureka:
  client:
    serviceUrl:
      defaultZone: \PYGZdl{}\PYGZob{}EUREKA\PYGZus{}DEFAULT\PYGZus{}ZONE:http://localhost:8000/eureka/\PYGZcb{}
    registryFetchIntervalSeconds: 10
\end{sphinxVerbatim}


\subsubsection{服务治理机制}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id1}}\label{\detokenize{01.spring-cloud/02.eureka/eureka_03::doc}}
\noindent\sphinxincludegraphics{{service_manager}.png}


\subsubsection{服务提供者}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id2}}

\paragraph{服务注册}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id3}}
服务启动时服务通过reset请求将自己注册到Eureka，同时带上服务的一些元数据信息。Eureka接收到reset请求后，将元数据信息存储在一个双层结构Map中，第一层的key是服务名，第二层的key是服务实例名。


\paragraph{服务同步}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id4}}
上图中两个服务提供者分别注册到两个注册中心，由于注册中心之间的相互注册，当服务提供者发送注册请求到一个注册中心时，它会将该请求转发到相连的其它注册中心，从而实现注册中心之间的服务同步。我们可以从任意一个注册中心获取所有的注册服务信息。


\paragraph{服务续约}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id5}}
服务注册完成之后，服务提供者将维护一个心跳来告诉注册中心服务还活着，防止注册中心将实例从服务列表中剔除。eureka.instance.lease-renewal-interval-in-second参数用于定义服务续约任务的调用间隔时间，默认30秒。eureka.instanc.lease-expiration-duration-in-seconds参数用于定义服务失效时间，默认90秒。


\subsubsection{服务消费者}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id6}}

\paragraph{获取服务}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id7}}
服务消费者启动时，将发送REST请求从服务注册中心获取注册的服务信息列表。为了性能考虑，Eureka会维护一份只度的服务清单来返回给客户端，同时该缓存清单会每隔30秒更新一次。eureka.client.registry-fetch-interval-seconds设置更新缓存服务清单时间。


\paragraph{服务调用}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id8}}
服务消费者在获取到服务信息列表后，通过服务名可以获取服务对应的实例名和元数据信息。消费者可以自己选择需要具体调用那个实例，在Ribbon中会默认采用轮询方式进行调用，从而实现客户端的负载均衡。


\paragraph{服务下线}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id9}}
系统运行过程中服务停止或重启，服务将发起一个REST请求给注册中心，注册中心将实例状态设置为下线，并且将这个时间传播出去


\subsubsection{服务注册中心}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id10}}

\paragraph{失效剔除}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id11}}
当服务超过设置的服务失效剔除时间，注册中心将中服务列表中剔除服务实例信息。


\paragraph{自我保护}
\label{\detokenize{01.spring-cloud/02.eureka/eureka_03:id12}}
当服务心跳失败比例小于85\%时，注册中心将启动自我保护机制，注册中心将不会剔除失效服务。


\subsection{Spring Cloud feign}
\label{\detokenize{01.spring-cloud/03.feign/feign:spring-cloud-feign}}\label{\detokenize{01.spring-cloud/03.feign/feign::doc}}

\subsubsection{Ribbon 简介}
\label{\detokenize{01.spring-cloud/03.feign/ribbon_01:ribbon}}\label{\detokenize{01.spring-cloud/03.feign/ribbon_01::doc}}
Spring Cloud Ribbon是基于HTTP和TCP的客户端负载均衡工具。其使用是内嵌到微服务中，提供微服务之间的调用，并支持客户端负载均衡。


\paragraph{客户端负载均衡}
\label{\detokenize{01.spring-cloud/03.feign/ribbon_01:id1}}
\noindent\sphinxincludegraphics{{balance_load}.jpeg}

通常说的负载均衡指服务端负载均衡，服务端负载均衡可分为软件负载均衡和硬件负载均衡。但无论是软件负载均衡还是硬件负载均衡都会在服务端维护一个服务列表，当用户调用服务资源时服务端将根据服务列表决定调用那个服务实例。
客户端负载均衡不同于服务端负载均衡，客户端负载均衡服务列表维护在客户端，客户端通过心跳维护服务端服务列表。客户端会每隔一段时间更新本地服务列表，Ribbon做为客户端负载均衡框架，可以负载均衡的方式调用服务实例，默认采用轮询的方式::
1.服务提供者启动多个服务实例
2.服务调用方通过使用@LoadBalanced注解修饰过的RestTemplate来实现向服务接口调用


\paragraph{常用配置属性}
\label{\detokenize{01.spring-cloud/03.feign/ribbon_01:id2}}
ribbon.key=value全局通用设置模式:
\begin{itemize}
\item {} 
ribbon.ReadTimeout: 客户端读取超时时间，超时时间要小于Hystrix的超时时间，否则重试机制就无意义了

\item {} 
ribbon.ConnectTimeout: 客户端连接超时时间

\item {} 
ribbon.OkToRetryOnAllOperations: 访问实例失败(超时)，允许自动重试

\item {} 
ribbon.MaxAutoRetries: 设置重试次数，失败后会更换实例访问，请一定确保接口的幂等性，否则重试可能导致数据异常

\item {} 
ribbon.MaxAutoRetriesNextServer: 切换服务器实例的重试次数

\end{itemize}

\textless{}client\textgreater{}.ribbon.key=value针对不同客户端设置模式:
\begin{itemize}
\item {} 
\textless{}client\textgreater{}.ribbon.ReadTimeout: 客户端读取超时时间，超时时间要小于Hystrix的超时时间，否则重试机制就无意义了

\item {} 
\textless{}client\textgreater{}.ribbon.ConnectTimeout: 客户端连接超时时间

\item {} 
\textless{}client\textgreater{}.ribbon.OkToRetryOnAllOperations: 访问实例失败(超时)，允许自动重试

\item {} 
\textless{}client\textgreater{}.ribbon.MaxAutoRetries: 设置重试次数，失败后会更换实例访问，请一定确保接口的幂等性，否则重试可能导致数据异常

\item {} 
\textless{}client\textgreater{}.ribbon.MaxAutoRetriesNextServer: 切换服务器实例的重试次数

\end{itemize}


\subsubsection{Hystrix 简介}
\label{\detokenize{01.spring-cloud/03.feign/hystrix_02:hystrix}}\label{\detokenize{01.spring-cloud/03.feign/hystrix_02::doc}}
Spring Cloud Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并、服务监控等功能。在微服务系统中存在多个服务单元，服务单元之间存在广泛依赖关系，当一个服务节点发生故障时可能会引发故障的蔓延导致整个系统不可用。在分布式架构中，断路器模式的作用就是为了解决这种问题。当某个单元发生故障是，熔断监控器将向调用方返回一个错误响应，防止线程因故障长时间占用得不到释放，导致故障蔓延系统瘫痪。


\paragraph{快速入门}
\label{\detokenize{01.spring-cloud/03.feign/hystrix_02:id1}}
1.创建一个Spring boot项目，命名为hello-service，在pom.xml中添加Hystrix依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{hystrix}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

2.在主类中使用@EnableCircuitBreaker注解开启断路器功能:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableCircuitBreaker}
\PYG{n+nd}{@EnableDiscoveryClient}
\PYG{n+nd}{@SpringBooApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{ConsumerApplication}\PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Bean}
    \PYG{n+nd}{@LoadBalanced}
    \PYG{n}{RestTemplate} \PYG{n}{restTemplate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{n}{new} \PYG{n}{RestTemplate}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}\PYG{p}{\PYGZob{}}

        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{ConsumerApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.添加服务方法,@HystrixCommand启动熔断功能，fallbackMethod指定服务降级调用方法，当调用服务发生故障或长时间未响应将调用服务降级方法，做后续处理:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@Service}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{HelloService}\PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Autowired}
    \PYG{n}{RestTemplate} \PYG{n}{restTemplate}\PYG{p}{;}

    \PYG{n+nd}{@HystrixCommand}\PYG{p}{(}\PYG{n}{fallbackMethod} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{helloFallback}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{public} \PYG{n}{String} \PYG{n}{helloService}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{n}{restTemplate}\PYG{o}{.}\PYG{n}{getForEntity}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://HELLO\PYGZhy{}SERVICE/hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{String}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getBody}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{String} \PYG{n}{helloFallback}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{error}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{属性详情}
\label{\detokenize{01.spring-cloud/03.feign/hystrix_02:id2}}
属性配置优先级
\begin{quote}

全局默认值: 没有显示设置属性值，Hystrix默认属性值

全局配置属性: 在配置文件中显示指定属性值覆盖默认值。系统启动时或通过Spring Cloud Config和Spring Cloud Bus动态刷新配置功能配合下，实现对系统默认值覆盖。

实例默认值: 通过代码对实例设置属性值覆盖默认值

实例配置属性: 通过配置文件来为实例进行属性配置
\end{quote}


\paragraph{常用配置属性}
\label{\detokenize{01.spring-cloud/03.feign/hystrix_02:id3}}
hystrix.command.default.execution.isolation.strategy: 配置执行隔离策略，THREAD通过线程池隔离，默认值。SEMAPHORE通过信号量隔离。

hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 配置执行超时时间，单位毫秒。调用接口超过设置时间将触发服务降级。

hystrix.command.default.execution.timeout.enabled: 设置是否启用超时时间，默认是true，如果设置成false，则超时时间配置不起作用。

hystrix.command.default.fallback.enabled: 是否启用服务降级策略，默认为true。

hystrix.threadpool.default.coreSize: 执行命令线程池的核心线程数，即命令执行的最大并发数。默认值为10。

hystrix.threadpool.default.maximumSize: 最大执行线程数。

hystrix.threadpool.default.maxQueueSize: 设置线程池最大队列大小。当为-1使用SynchronousQueue实现的队列，否则使用LinekedBlockingQueue实现的队列。


\subsubsection{Feign 简介}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:feign}}\label{\detokenize{01.spring-cloud/03.feign/feign_03::doc}}
Spring Cloud Feign整合了Spring Cloud Ribbon与Spring Cloud Hystrix，除提供两者强大功能外，提供了一种声明式的web服务客户端定义方式。只用使用注解便能轻松使用Feign客户端。


\paragraph{快速入门}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:id1}}
1.创建一个Spring boot项目，命名为hello-service，在pom.xml中添加Hystrix依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{feign}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

2.在主类中使用@EnableFeignClients注解开启Feign功能支持:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableFeignClients}
\PYG{n+nd}{@EnableDiscoveryClient}
\PYG{n+nd}{@SpringBooApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{ConsumerApplication}\PYG{p}{\PYGZob{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}\PYG{p}{\PYGZob{}}

        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{ConsumerApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}

    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.定义SslmRemoteService接口，通过@FeignClient的value属性指定服务名来绑定服务，fallback属性指定服务降级调用方法类，path属性指定公共的URL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@FeignClient}\PYG{p}{(}\PYG{n}{value} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{srm\PYGZhy{}supplier\PYGZhy{}lifecycle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fallback} \PYG{o}{=} \PYG{n}{SslmRemoteServiceFallback}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/v1/}\PYG{l+s+si}{\PYGZob{}organizationId\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{public} \PYG{n}{interface} \PYG{n}{SslmRemoteService}\PYG{p}{\PYGZob{}}

    \PYG{o}{/}\PYG{o}{*}\PYG{o}{*}
    \PYG{o}{*}\PYG{n}{创建调查表头并发布调查表}
    \PYG{o}{*}
    \PYG{o}{*} \PYG{n+nd}{@param} \PYG{n}{organizationId}
    \PYG{o}{*} \PYG{n+nd}{@param} \PYG{n}{investigateHeaderList}
    \PYG{o}{*} \PYG{n+nd}{@return} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{InvestigateHeaderVO}\PYG{o}{\PYGZgt{}}
    \PYG{o}{*}\PYG{o}{/}
    \PYG{n+nd}{@PostMapping}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/investigate/save\PYGZhy{}release}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{InvestigateHeaderVO}\PYG{o}{\PYGZgt{}} \PYG{n}{batchSaveAndReleaseInvestgHeader}\PYG{p}{(}\PYG{n+nd}{@PathVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{organizationId}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{n}{Long} \PYG{n}{organizationId}\PYG{p}{,}
                                                                \PYG{n+nd}{@RequestBody} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{InvestigateHeaderVO}\PYG{o}{\PYGZgt{}} \PYG{n}{investigateHeaderList}\PYG{p}{)}\PYG{p}{;}


\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

4.定义SslmRemoteServiceFallback回调方法类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@Component}
\PYG{n+nd}{@SuppressWarnings}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{all}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{SslmRemoteServiceFallback} \PYG{n}{implements} \PYG{n}{SslmRemoteService}\PYG{p}{\PYGZob{}}

    \PYG{n}{private} \PYG{n}{static} \PYG{n}{final} \PYG{n}{Logger} \PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{LoggerFactory}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n}{SslmRemoteServiceFallback}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{InvestigateHeaderVO}\PYG{o}{\PYGZgt{}} \PYG{n}{batchSaveAndReleaseInvestgHeader}\PYG{p}{(}\PYG{n}{Long} \PYG{n}{organizationId}\PYG{p}{,} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{InvestigateHeaderVO}\PYG{o}{\PYGZgt{}} \PYG{n}{investigateHeaderList}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{LOGGER}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Post batch save and release investgHeader fail}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{throw} \PYG{n}{new} \PYG{n}{CommonException}\PYG{p}{(}\PYG{n}{BaseConstants}\PYG{o}{.}\PYG{n}{ErrorCode}\PYG{o}{.}\PYG{n}{ERROR}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Feign 属性配置}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:id2}}
Spring Cloud Feign整合了Spring Cloud Ribbon和Spring Cloud Hystrix，所以对于负载均衡、熔断降级的配置可以按Ribbon和Hystrix的配置。


\paragraph{Ribbon配置}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:ribbon}}
@FeignClient中name或value属性指定的服务名即Ribbon客户端的名，因此Feign中想对不同客户端做不同配置可以根据\textless{}client\textgreater{}.ribbon.key=value进行配置


\paragraph{Hystrix配置}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:hystrix}}\begin{quote}

feign.hystrix.enabled: 设置是否开启Feign 客户端Hystrix支持。
\end{quote}


\paragraph{禁用Hystrix配置}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:id3}}
除通过feign.hystrix.enabled设置外还可针对服务客户端关闭Hystrix支持

1.创建关闭Hystrix配置类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@Configuration}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{DisableHystrixConfiguration}\PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Bean}
    \PYG{n+nd}{@Scope}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prototype}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{public} \PYG{n}{Feign}\PYG{o}{.}\PYG{n}{Builder} \PYG{n}{feignBuilder}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{Feign}\PYG{o}{.}\PYG{n}{builder}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

2.通过@FeignClient注解中，configuration参数引入配置:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@FeignClient}\PYG{p}{(}\PYG{n}{value} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello\PYGZhy{}service}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{configuration} \PYG{o}{=} \PYG{n}{DisableHystrixConfiguration}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}
\PYG{n}{public} \PYG{n}{interface} \PYG{n}{HelloService}\PYG{p}{\PYGZob{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{Feign配置属性}
\label{\detokenize{01.spring-cloud/03.feign/feign_03:id4}}\begin{quote}

feign.compression.request.enabled: 设置是否开启请求GZIP压缩功能
feign.compression.response.enabled: 设置是否开启响应GZIP压缩功能
feign.compression.request.mime-type: 设置GZIP压缩请求的类型，默认text/xml,application/xml,application/json
feign.compression.request.min-request-size: 设置GZIP压缩请求大小下限，超过的请求将被压缩
\end{quote}


\subsection{Spring Cloud Zuul}
\label{\detokenize{01.spring-cloud/04.zuul/zuul:spring-cloud-zuul}}\label{\detokenize{01.spring-cloud/04.zuul/zuul::doc}}

\subsubsection{简介}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id1}}\label{\detokenize{01.spring-cloud/04.zuul/zuul_01::doc}}
API网关作为微服务系统提供对外资源的入口，起到了对服务资源进行统一管理的作用。除了要实现请求路由、负载均衡、校验过滤等功能外，还需要与服务治理框架结合、请求转发时的熔断机制、服务聚合等。Spring cloud Zuul是spring微服务架构提供的API网关解决方案，它通过与Eureka注册中心整合，可以方便的获取到系统中的服务信息。Zuul作为微服务系统的入口可以方便的管理服务资源，对请求进行统一的管理，可以添加拦截校验等逻辑。


\subsubsection{快速入门}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id2}}
\noindent\sphinxincludegraphics{{zuul}.jpeg}

1.创建一个Spring Boot工程，命名为api-gateway，并在pom.xml中添加如下依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.cloud\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}zuul\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.cloud\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}eureka\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}

spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}zuul除包含zuul\PYGZhy{}core外还包括:
    spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}hystrix: 该依赖主要实现对网关服务转发的保护机制，通过线程隔离和断路器，防止微服务故障引发API网关资源无法释放。
    spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}ribbon: 网关服务在进行路由转发时实现负载均衡
    spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}actuator: 提供微服务管理端点。Zuul还提供了/routes端点返回当前所有路由规则
\end{sphinxVerbatim}

2.创建主类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableZuulProxy}
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{GatewayApplication} \PYG{p}{\PYGZob{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{GatewayApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{常用配置}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id3}}

\paragraph{请求路由}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id4}}\begin{itemize}
\item {} 
zuul.routes.\textless{}自定义路由名\textgreater{}.path: 设置请求匹配路由

\item {} 
zuul.routes.\textless{}自定义路由名\textgreater{}.serviceId: 设置匹配路由将会发送到的微服务

\item {} 
zuul.routes.\textless{}自定义路由名\textgreater{}.url: 设置匹配路由将会发送到的url

\item {} 
zuul.ignored-services: 设置匹配表达式的Service Zuul将不会建立默认路由规则

\item {} 
zuul.ignored-patterns: 设置忽略匹配路径

\item {} 
zuul.retryable: 设置全局是否关闭请求重试

\item {} 
zuul.routes.\textless{}route\textgreater{}.retryable: 设置指定路由是否关闭请求重试

\end{itemize}


\paragraph{请求过滤}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id5}}
1.添加zuul过滤器类。继承ZuulFiter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/**
* 添加token和label到请求header
*
* @author flyleft
*/
public class HeaderWrapperFilter extends ZuulFilter \PYGZob{}

    private static final Logger LOGGER = LoggerFactory.getLogger(HeaderWrapperFilter.class);

    private GatewayProperties gatewayHelperProperties;

    public HeaderWrapperFilter(GatewayProperties gatewayHelperProperties) \PYGZob{}
        this.gatewayHelperProperties = gatewayHelperProperties;
    \PYGZcb{}

    private static final int HEADER\PYGZus{}WRAPPER\PYGZus{}FILTER = \PYGZhy{}1;

    /**
     * 过滤器类型，决定过滤器在那个生命周期中执行。pre表示在被路由之前执行，route表示在路由请求时被调用，post表示在route和error过滤器之后被调用，error表示处理请求发生错误时被调用
     */
    @Override
    public String filterType() \PYGZob{}
        return \PYGZdq{}pre\PYGZdq{};
    \PYGZcb{}

    /**
     *过滤器执行顺序，值越小优先级越高
     */
    @Override
    public int filterOrder() \PYGZob{}
        return 0;
    \PYGZcb{}

    /**
     *过滤器是否需要被执行
     */
    @Override
    public boolean shouldFilter() \PYGZob{}
        return true;
    \PYGZcb{}

    /**
     *过滤器的具体逻辑
     */
    @Override
    public Object run() \PYGZob{}
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        String token = (String) request.getAttribute(HEADER\PYGZus{}JWT);
        if (StringUtils.isEmpty(token)) \PYGZob{}
            LOGGER.info(\PYGZdq{}Request get empty jwt , request uri: \PYGZob{}\PYGZcb{} method: \PYGZob{}\PYGZcb{}\PYGZdq{}, request.getRequestURI(), request.getMethod());
        \PYGZcb{} else \PYGZob{}
            ctx.addZuulRequestHeader(HEADER\PYGZus{}TOKEN, token);
            if (gatewayHelperProperties.isEnabledJwtLog()) \PYGZob{}
                LOGGER.info(\PYGZdq{}Request get jwt , request uri: \PYGZob{}\PYGZcb{} method: \PYGZob{}\PYGZcb{} JWT: \PYGZob{}\PYGZcb{}\PYGZdq{},
                        request.getRequestURI(), request.getMethod(), token);
            \PYGZcb{}
        \PYGZcb{}
        return null;
    \PYGZcb{}
\end{sphinxVerbatim}

2.将过滤器添加到IOC容器中，创建配置类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{*}\PYG{o}{*}
\PYG{o}{*} \PYG{n}{自定义configuration配置类}
\PYG{o}{*}
\PYG{o}{*} \PYG{n+nd}{@author} \PYG{n}{flyleft}
\PYG{o}{*}\PYG{o}{/}
\PYG{n+nd}{@Configuration}
\PYG{n+nd}{@EnableConfigurationProperties}\PYG{p}{(}\PYG{n}{GatewayProperties}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{CustomZuulConfig} \PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Bean}
    \PYG{n}{public} \PYG{n}{HeaderWrapperFilter} \PYG{n}{headerWrapperFilter}\PYG{p}{(}\PYG{n}{GatewayProperties} \PYG{n}{gatewayHelperProperties}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{new} \PYG{n}{HeaderWrapperFilter}\PYG{p}{(}\PYG{n}{gatewayHelperProperties}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{路径匹配}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id6}}
路径匹配当匹配到一个满足路径表达式时匹配结束。因此需要保证配置文件读取到有序，需要使用YAML配置文件
\begin{itemize}
\item {} 
?: 表示匹配任意单个字符

\item {} 
{\color{red}\bfseries{}*}: 表示匹配任意数量的字符

\item {} 
{\color{red}\bfseries{}**}: 表示匹配任意数量的字符，支持多级目录

\end{itemize}


\paragraph{路由前缀}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id11}}\begin{itemize}
\item {} 
zuul.prefix: 为全局的路由规则设置前缀信息

\item {} 
zuul.stripPrefix: 关闭移除代理前缀的动作

\item {} 
zuul.routes.\textless{}route\textgreater{}.strip-prefix: 关闭指定路由移除代理前缀动作

\end{itemize}


\paragraph{Cookie与头信息}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:cookie}}\begin{itemize}
\item {} 
zuul.sensitiveHeaders: 设置Zuul的敏感头信息，默认包括Cookie、Set-Cookie、Authorization。设置为敏感头信息的内容将在路由时被网关过滤。

\item {} 
zuul.routes.\textless{}router\textgreater{}.customSensitiveHeaders: 设置指定路由开启自定义敏感头，将去除默认敏感头设置

\item {} 
zuul.routes.\textless{}router\textgreater{}.sensitiveHeaders: 设置指定路由的敏感头

\end{itemize}


\paragraph{重定向问题}
\label{\detokenize{01.spring-cloud/04.zuul/zuul_01:id12}}
系统内部重定向跳转，Location指向具体服务实例地址，导致请求没有通过网关控制
\begin{itemize}
\item {} 
zuul.addHostHeader: 设置请求转发前设置Host头信息，标识最初的服务端请求地址,默认false，设置为true将表示最初服务端请求地址

\end{itemize}


\subsection{Spring Cloud Config}
\label{\detokenize{01.spring-cloud/05.config/config:spring-cloud-config}}\label{\detokenize{01.spring-cloud/05.config/config::doc}}

\subsubsection{简介}
\label{\detokenize{01.spring-cloud/05.config/config_01:id1}}\label{\detokenize{01.spring-cloud/05.config/config_01::doc}}
Spring Cloud Config用来为分布式系统中基础设施和微服务应用提供集中化的外部配置支持，分为服务端和客户端两部分。服务端作为独立的微服务，用来链接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；客户端内嵌在微服务中，当微服务启动时将从配置的配置中心获取和加载配置信息。


\subsubsection{快速入门}
\label{\detokenize{01.spring-cloud/05.config/config_01:id2}}
1.创建一个Spring Boot工程，命名为config-server，并在pom.xml中添加如下依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{config}\PYG{o}{\PYGZhy{}}\PYG{n}{service}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{eureka}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

2.创建主类,添加@EnableConfigServer开启Spring Cloud Config的服务端功能:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableConfigServer}
\PYG{n+nd}{@EnableDiscoveryClent}
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{ConfigServerApplication} \PYG{p}{\PYGZob{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{ConfigServerApplication}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.配置文件中添加Git仓库的相关信息:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
spring.cloud.config.server.git.uri: 配置Git仓库位置
spring.cloud.config.server.git.searchPaths: 配置路径下的相对搜索位置，可以配置多个
spring.cloud.config.server.git.usernane: 配置访问Git仓库的用户信息
spring.cloud.config.server.git.password: 配置访问Git仓库的用户名秘密
spring.cloud.config.server.git.basedir: 设置配置中心缓存拉取配置文件的目录
\end{sphinxVerbatim}

4.创建配置仓库

根据config-server中配置的Git仓库位置创建仓库，并根据不同环境新建对应的配置文件:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{configspace}\PYG{o}{.}\PYG{n}{properties}
\PYG{n}{configspace}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}\PYG{o}{.}\PYG{n}{properties}
\PYG{n}{configspace}\PYG{o}{\PYGZhy{}}\PYG{n}{test}\PYG{o}{.}\PYG{n}{properties}
\PYG{n}{configsapce}\PYG{o}{\PYGZhy{}}\PYG{n}{prod}\PYG{o}{.}\PYG{n}{properties}
\end{sphinxVerbatim}

访问配置信息的URL与配置文件的映射关系，application对应应用名，profile对应环境名，label对应Git上不同分支:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{application}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{profile}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{label}\PYG{p}{\PYGZcb{}}\PYG{p}{]}
\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{application}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{profile}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{yml}
\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{label}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{application}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZhy{}}\PYG{p}{\PYGZob{}}\PYG{n}{profile}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{yml}
\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{application}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{profile}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{properties}
\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{label}\PYG{p}{\PYGZcb{}}\PYG{o}{/}\PYG{p}{\PYGZob{}}\PYG{n}{application}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZhy{}}\PYG{p}{\PYGZob{}}\PYG{n}{profile}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{properties}
\end{sphinxVerbatim}

微服务应用从配置中心获取配置文件时，配置中心将通过git clone加载配置文件到配置中心本地，并将这些配置文件返回给微服务应用。即使配置中心不能访问Git配置文件地址时也能返回配置文件


\subsubsection{客户端配置}
\label{\detokenize{01.spring-cloud/05.config/config_01:id3}}
1.创建一个Spring Boot应用，命名为config-client，并在pom.xml中添加如下依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.cloud\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}config\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.cloud\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}cloud\PYGZhy{}starter\PYGZhy{}eureka\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}

\PYGZlt{}!\PYGZhy{}\PYGZhy{} 配置访问配置中心失败时重试依赖 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.retry\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}retry\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}org.springframework.boot\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZhy{}aop\PYGZlt{}/artifactId\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}
\end{sphinxVerbatim}

2.创建Spring Boot主类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableDiscoveryClent}
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{Application} \PYG{p}{\PYGZob{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{Application}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.配置文件bootstrap.properties中添加如下配置项:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
spring.application.name: 配置获取配置文件的服务名
spring.cloud.config.profile: 配置获取配置文件的环境名
spring.cloud.config.label: 配置获取配置文件的版本
spring.cloud.config.url: 配置中心的地址

spring.cloud.config.discovery.enable: 设置是否开启服务名访问配置中心功能
spring.cloud.config.discovery.serviceId: 设置要访问配置中心服务名

spring.cloud.config.failFast: 设置客户端启动时是否优先尝试判断从配置中心获取配置信息是否正常
spring.cloud.config.retry.multiplier: 设置初始重试间隔时间
spring.cloud.config.retry.initial\PYGZhy{}interval: 设置下一间隔的乘数
spring.cloud.config.retry.max\PYGZhy{}interval: 设置最大间隔时间，默认为2000毫秒
spring.cloud.config.retry.max\PYGZhy{}attempts: 设置最大重试次数，默认为6次
\end{sphinxVerbatim}


\subsection{Spring Cloud Bus}
\label{\detokenize{01.spring-cloud/06.bus/bus:spring-cloud-bus}}\label{\detokenize{01.spring-cloud/06.bus/bus::doc}}

\subsubsection{简介}
\label{\detokenize{01.spring-cloud/06.bus/bus_01:id1}}\label{\detokenize{01.spring-cloud/06.bus/bus_01::doc}}
消息总线使用轻量级消息代理实现构建一个公共的消息主题让所有微服务实例都连接上来，在这个消息主题中生产的消息所有实例都能监听和消费。


\subsubsection{快速入门}
\label{\detokenize{01.spring-cloud/06.bus/bus_01:id2}}
1.部署搭建kafka相关环境

2.修改config-server配置中心，并在pom.xml中添加如下依赖，其它需要更新外部配置文件的服务也加入该依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{starter}\PYG{o}{\PYGZhy{}}\PYG{n}{bus}\PYG{o}{\PYGZhy{}}\PYG{n}{kafka}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

3.配置文件中配置kafka相关连接信息:

4.设置配置文件仓库更新时通过Web Hook发起请求/bus/refresh?destination= 到配置中心服务


\subsection{Spring Cloud Stream}
\label{\detokenize{01.spring-cloud/07.stream/stream:spring-cloud-stream}}\label{\detokenize{01.spring-cloud/07.stream/stream::doc}}

\subsubsection{简介}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id1}}\label{\detokenize{01.spring-cloud/07.stream/stream_01::doc}}
Spring Cloud Stream 是一个为微服务构建消息驱动能力的框架。整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务架构。有效的简化了开发人员对消息中间件的使用复杂度，让开发人员有更多的精力去关注于核心业务代码。


\subsubsection{快速入门}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id2}}
1.创建Spring Boot 项目，命名stream-demo，pom.xml中添加如下依赖:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{springframework}\PYG{o}{.}\PYG{n}{cloud}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{spring}\PYG{o}{\PYGZhy{}}\PYG{n}{cloud}\PYG{o}{\PYGZhy{}}\PYG{n}{stream}\PYG{o}{\PYGZhy{}}\PYG{n}{binder}\PYG{o}{\PYGZhy{}}\PYG{n}{kafka}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

2.创建自定义通道接口，SendAndReceive:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{interface} \PYG{n}{SendAndReceive}\PYG{p}{\PYGZob{}}

    \PYG{n}{String} \PYG{n}{SEND1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{send1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{String} \PYG{n}{SEND2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{send2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{String} \PYG{n}{SEND3} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{send3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{String} \PYG{n}{INPUT1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INPUT1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{String} \PYG{n}{INPUT2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INPUT2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n}{String} \PYG{n}{INPUT3} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INPUT3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}

    \PYG{n+nd}{@Input}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{INPUT1}\PYG{p}{)}
    \PYG{n}{SubscribableChannel} \PYG{n}{input1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Input}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{INPUT2}\PYG{p}{)}
    \PYG{n}{SubscribableChannel} \PYG{n}{input2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Input}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{INPUT3}\PYG{p}{)}
    \PYG{n}{SubscribableChannel} \PYG{n}{input3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Output}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{SEND1}\PYG{p}{)}
    \PYG{n}{MessageChannel} \PYG{n}{send1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Output}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{SEND2}\PYG{p}{)}
    \PYG{n}{MessageChannel} \PYG{n}{send2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nd}{@Output}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{SEND3}\PYG{p}{)}
    \PYG{n}{MessageChannel} \PYG{n}{send3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

3.创建消息接收发送类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@EnableBinding}\PYG{p}{(}\PYG{n}{SendAndReceive}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}
\PYG{n+nd}{@WebAppConfiguration}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{ReciverAndSend}\PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Autowired}
    \PYG{n}{private} \PYG{n}{SendAndReceive} \PYG{n}{sendAndReceive}\PYG{p}{;}

    \PYG{n+nd}{@StreamListener}\PYG{p}{(}\PYG{n}{Sink}\PYG{o}{.}\PYG{n}{INPUT1}\PYG{p}{)}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{revice1}\PYG{p}{(}\PYG{n}{Object} \PYG{n}{payload}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@StreamListener}\PYG{p}{(}\PYG{n}{Sink}\PYG{o}{.}\PYG{n}{INPUT2}\PYG{p}{)}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{revice2}\PYG{p}{(}\PYG{n}{Object} \PYG{n}{payload}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@StreamListener}\PYG{p}{(}\PYG{n}{Sink}\PYG{o}{.}\PYG{n}{INPUT3}\PYG{p}{)}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{revice3}\PYG{p}{(}\PYG{n}{Object} \PYG{n}{payload}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{void} \PYG{n}{send1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{sendAndReceive}\PYG{o}{.}\PYG{n}{send1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{MessageBuilder}\PYG{o}{.}\PYG{n}{withPayload}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{内容}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{void} \PYG{n}{send2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{sendAndReceive}\PYG{o}{.}\PYG{n}{send2}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{MessageBuilder}\PYG{o}{.}\PYG{n}{withPayload}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{内容}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}

     \PYG{n}{public} \PYG{n}{void} \PYG{n}{send3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{sendAndReceive}\PYG{o}{.}\PYG{n}{send2}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{MessageBuilder}\PYG{o}{.}\PYG{n}{withPayload}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{内容}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

4.创建服务启动类:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@SpringBootApplication}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{Application} \PYG{p}{\PYGZob{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{main}\PYG{p}{(}\PYG{n}{String}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{SpringApplication}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{Application}\PYG{o}{.}\PYG{n}{class}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

5.配置文件中添加如下配置:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
spring.cloud.stream.defaultBinder: 配置默认绑定器，比如kafka
spring.cloud.stream.bindings.input1.group: 为具体通道绑定分组名，通常设置成服务名
spring.cloud.stream.bindings.input1.destination: 设置具体通道消费主题
spring.cloud.stream.bindings.output1.destination: 设置具体通道输出消息的主题
spring.cloud.stream.bindings.input1.content\PYGZhy{}type: 设置输入通道MIME类型
spring.cloud.stream.kafka.binder.brokers: 配置kafka地址
...
\end{sphinxVerbatim}


\subsubsection{核心概念}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id3}}
Spring Cloud Stream构建的应用程序与消息中间件之间通过绑定器Binder相关联，绑定器相对于应用程序而言起到了隔离作用，它使得不同消息中间件的实现细节对应用程序是透明的，我们只需要使用Binder提供的抽象概念来使用消息中间件，这个抽象概念就是Channel。


\paragraph{绑定器}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id4}}
绑定器通过channel通道完美的实现了应用程序与消息中间件细节之间的隔离解耦，对于更换消息中间件只需要更换对应的Binder绑定器而不用需改任何代码逻辑。


\paragraph{发布订阅模式}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id5}}
Spring Cloud Stream中的消息通信方式遵循发布-订阅模式，当一条消息投递到消息中间件后，会通过共享的Topic主题进行广播，消息订阅者接收消息并触发自身逻辑。


\paragraph{消息分组}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id6}}
spring.cloud.stream.bindings.input.group可以为应用实例指定分组，如果不显示为应用指定分组，Spring Cloud Stream将为其分配一个独立的匿名消费组。对于同一个Topic下同一分组的应用实例只有一个会消费。


\paragraph{消息分区}
\label{\detokenize{01.spring-cloud/07.stream/stream_01:id7}}
通过消息分区可以实现当生产者将消息数据发送给多个消费者实例时，保证拥有相同特征的消息数据始终是由同一个消费者实例接收处理，



\renewcommand{\indexname}{Index}
\printindex
\end{document}